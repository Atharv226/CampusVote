const express = require('express');
const mongoose = require('mongoose');
const auth = require('../middleware/auth');
const Vote = require('../models/Vote');
const Election = require('../models/Election');
const Candidate = require('../models/Candidate');
const User = require('../models/User');
const { 
  emitVoteCast, 
  emitTurnoutMilestone, 
  emitVotingHistoryUpdate, 
  emitVotingStatsUpdate, 
  emitLiveElectionStats 
} = require('../socket/socketConfig');

const router = express.Router();

// @route   GET /api/voting/candidates/:electionId
// @desc    List candidates for an election grouped by position
// @access  Private
router.get('/candidates/:electionId', auth, async (req, res) => {
  try {
    const election = await Election.findById(req.params.electionId);
    if (!election) {
      return res.status(404).json({ error: 'Election not found' });
    }

    const candidates = await Candidate.find({
      electionId: req.params.electionId,
      isApproved: true,
      isActive: true
    }).populate('userId', 'name branch year');

    // Group by position
    const grouped = candidates.reduce((acc, c) => {
      if (!acc[c.position]) acc[c.position] = [];
      acc[c.position].push({
        _id: c._id,
        name: c.userId?.name,
        manifesto: c.manifesto,
        position: c.position
      });
      return acc;
    }, {});

    res.json({ election: { id: election._id, title: election.title }, candidates: grouped });
  } catch (error) {
    console.error('List candidates error:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// @route   POST /api/voting/cast-vote
// @desc    Cast a vote
// @access  Private
router.post('/cast-vote', auth, async (req, res) => {
  try {
    console.log('Vote casting attempt:', {
      userId: req.user.id,
      body: req.body,
      headers: req.headers['x-auth-token'] ? 'Token present' : 'No token'
    });
    
    const { electionId, candidateId, position } = req.body;

    if (!electionId || !candidateId || !position) {
      console.log('Missing required fields:', { electionId, candidateId, position });
      return res.status(400).json({ error: 'Missing required fields: electionId, candidateId, position' });
    }
    
    // Validate ObjectId format
    if (!mongoose.Types.ObjectId.isValid(electionId)) {
      console.log('Invalid electionId format:', electionId);
      return res.status(400).json({ error: 'Invalid election ID format' });
    }
    
    if (!mongoose.Types.ObjectId.isValid(candidateId)) {
      console.log('Invalid candidateId format:', candidateId);
      return res.status(400).json({ error: 'Invalid candidate ID format' });
    }

    // Check if election is active
    const election = await Election.findById(electionId);
    console.log('Found election:', election ? `${election.title} (${election.status})` : 'Not found');
    
    if (!election || election.status !== 'active') {
      return res.status(400).json({ error: 'Election is not active' });
    }
    
    // Check if candidate exists
    const candidate = await Candidate.findById(candidateId);
    console.log('Found candidate:', candidate ? `${candidate.position} candidate` : 'Not found');
    
    if (!candidate) {
      return res.status(400).json({ error: 'Candidate not found' });
    }
    
    // Validate that candidate belongs to the election
    if (candidate.electionId.toString() !== electionId) {
      console.log('Election mismatch:', {
        candidateElectionId: candidate.electionId.toString(),
        requestElectionId: electionId,
        match: candidate.electionId.toString() === electionId
      });
      return res.status(400).json({ error: 'Candidate does not belong to this election' });
    }
    
    // Validate that candidate is approved
    if (!candidate.isApproved) {
      console.log('Candidate not approved:', candidateId);
      return res.status(400).json({ error: 'Candidate is not approved' });
    }

    // Check if user has already voted
    const existingVote = await Vote.findOne({
      electionId,
      voterId: req.user.id,
      position
    });
    console.log('Existing vote check:', { found: !!existingVote, userId: req.user.id, electionId, position });

    if (existingVote) {
      return res.status(400).json({ error: 'You have already voted for this position' });
    }

    console.log('All validations passed, creating vote:', {
      electionId,
      voterId: req.user.id,
      candidateId,
      position
    });

    // Create new vote with proper ObjectId conversion
    const vote = new Vote({
      electionId: new mongoose.Types.ObjectId(electionId),
      voterId: new mongoose.Types.ObjectId(req.user.id),
      candidateId: new mongoose.Types.ObjectId(candidateId),
      position,
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
      // voteHash will be generated by pre-save middleware
      // verificationToken will be generated by pre-save middleware
    });

    console.log('Attempting to save vote...');
    console.log('Vote object before save:', {
      electionId: vote.electionId,
      voterId: vote.voterId,
      candidateId: vote.candidateId,
      position: vote.position,
      hasPreSaveHook: typeof vote.generateVoteHash === 'function'
    });
    
    await vote.save();
    console.log('Vote saved successfully:', vote._id);
    console.log('Final vote object:', {
      id: vote._id,
      voteHash: vote.voteHash,
      verificationToken: vote.verificationToken ? 'Generated' : 'Missing',
      castAt: vote.castAt
    });

    // Get updated vote counts and turnout for real-time updates
    const totalVotes = await Vote.countDocuments({ electionId });
    const eligibleVoters = await User.countDocuments({
      role: 'voter',
      isActive: true,
      branch: { $in: election.allowedBranches },
      year: { $in: election.allowedYears }
    });
    
    const turnoutPercentage = eligibleVoters > 0 ? Math.round((totalVotes / eligibleVoters) * 1000) / 10 : 0;
    
    // Get updated results for live display
    const liveResults = await Vote.aggregate([
      { $match: { electionId: election._id } },
      { $group: { _id: { candidateId: '$candidateId', position: '$position' }, count: { $sum: 1 } } },
      { $lookup: { from: 'candidates', localField: '_id.candidateId', foreignField: '_id', as: 'candidate' } },
      { $unwind: '$candidate' },
      { $lookup: { from: 'users', localField: 'candidate.userId', foreignField: '_id', as: 'user' } },
      { $unwind: '$user' },
      { $project: {
        position: '$_id.position',
        candidateId: '$_id.candidateId',
        candidateName: '$user.name',
        votes: '$count'
      }},
      { $sort: { position: 1, votes: -1 } }
    ]);
    
    // Group results by position
    const resultsByPosition = liveResults.reduce((acc, result) => {
      if (!acc[result.position]) {
        acc[result.position] = [];
      }
      acc[result.position].push({
        candidateId: result.candidateId,
        name: result.candidateName,
        votes: result.votes
      });
      return acc;
    }, {});
    
    // Emit real-time updates
    emitVoteCast(electionId, {
      totalVotes,
      turnoutPercentage,
      results: resultsByPosition
    });
    
    // Emit live election stats update
    emitLiveElectionStats(electionId, {
      totalVotes,
      eligibleVoters,
      turnoutPercentage,
      votesByPosition: Object.keys(resultsByPosition).map(position => ({
        position,
        votes: resultsByPosition[position].reduce((sum, candidate) => sum + candidate.votes, 0)
      })),
      lastVoteAt: new Date()
    });
    
    // Update user's voting statistics
    try {
      const userStats = await Vote.countDocuments({ voterId: req.user.id });
      emitVotingStatsUpdate(req.user.id, {
        totalVotesCast: userStats,
        lastVoteAt: new Date()
      });
    } catch (statsError) {
      console.warn('Failed to emit voting stats update:', statsError.message);
    }
    
    // Check for turnout milestones and emit notifications
    const milestones = [25, 50, 75, 90];
    const previousTurnout = Math.round(((totalVotes - 1) / eligibleVoters) * 1000) / 10;
    
    for (const milestone of milestones) {
      if (turnoutPercentage >= milestone && previousTurnout < milestone) {
        emitTurnoutMilestone(electionId, milestone, turnoutPercentage);
        break;
      }
    }

    res.json({ message: 'Vote cast successfully', vote, turnoutPercentage });
  } catch (error) {
    console.error('Cast vote error details:', {
      message: error.message,
      stack: error.stack,
      name: error.name,
      requestBody: req.body,
      userId: req.user.id
    });
    
    // Send more specific error information
    res.status(500).json({ 
      error: 'Server error', 
      details: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// @route   GET /api/voting/results/:electionId
// @desc    Get election results summary by position and candidate
// @access  Private/Admin (for now keep public summary)
router.get('/results/:electionId', async (req, res) => {
  try {
    const election = await Election.findById(req.params.electionId);
    if (!election) {
      return res.status(404).json({ error: 'Election not found' });
    }

    const aggregation = await Vote.aggregate([
      { $match: { electionId: election._id } },
      { $group: { _id: { candidateId: '$candidateId', position: '$position' }, count: { $sum: 1 } } },
      { $lookup: { from: 'candidates', localField: '_id.candidateId', foreignField: '_id', as: 'candidate' } },
      { $unwind: '$candidate' },
      { $lookup: { from: 'users', localField: 'candidate.userId', foreignField: '_id', as: 'user' } },
      { $unwind: '$user' },
      { $project: { position: '$_id.position', candidateId: '$_id.candidateId', votes: '$count', name: '$user.name' } },
      { $sort: { position: 1, votes: -1 } }
    ]);

    // Group by position for easier consumption
    const results = aggregation.reduce((acc, row) => {
      if (!acc[row.position]) acc[row.position] = [];
      acc[row.position].push({ candidateId: row.candidateId, name: row.name, votes: row.votes });
      return acc;
    }, {});

    res.json({ election: { id: election._id, title: election.title }, results });
  } catch (error) {
    console.error('Get results error:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// @route   GET /api/voting/history
// @desc    Get user's voting history with comprehensive statistics
// @access  Private
router.get('/history', auth, async (req, res) => {
  try {
    const { filter = 'all', sortBy = 'date' } = req.query;
    
    // Get user's votes with election and candidate details
    const votesQuery = Vote.find({ voterId: req.user.id })
      .populate({
        path: 'electionId',
        select: 'title status startDate endDate positions totalVotesCast'
      })
      .populate({
        path: 'candidateId',
        select: 'position manifesto userId',
        populate: {
          path: 'userId',
          select: 'name branch year'
        }
      });

    // Apply sorting
    if (sortBy === 'date') {
      votesQuery.sort({ castAt: -1 });
    } else if (sortBy === 'election') {
      votesQuery.sort({ 'electionId.title': 1 });
    }

    const votes = await votesQuery;
    
    // Get election results for each vote to determine winners
    const historyWithResults = await Promise.all(votes.map(async (vote) => {
      // Get results for this election and position
      const positionResults = await Vote.aggregate([
        { $match: { 
          electionId: vote.electionId._id,
          position: vote.candidateId.position 
        }},
        { $group: { 
          _id: '$candidateId', 
          votes: { $sum: 1 } 
        }},
        { $sort: { votes: -1 } },
        { $lookup: {
          from: 'candidates',
          localField: '_id',
          foreignField: '_id',
          as: 'candidate'
        }},
        { $unwind: '$candidate' },
        { $lookup: {
          from: 'users',
          localField: 'candidate.userId',
          foreignField: '_id',
          as: 'user'
        }},
        { $unwind: '$user' },
        { $project: {
          candidateId: '$_id',
          name: '$user.name',
          votes: 1,
          rank: { $literal: 0 }
        }}
      ]);
      
      // Add ranking
      positionResults.forEach((result, index) => {
        result.rank = index + 1;
      });
      
      const winner = positionResults[0];
      const userCandidateResult = positionResults.find(r => 
        r.candidateId.toString() === vote.candidateId._id.toString()
      );
      
      const totalVotesForPosition = positionResults.reduce((sum, r) => sum + r.votes, 0);
      
      return {
        id: vote._id,
        voteHash: vote.voteHash,
        verificationToken: vote.verificationToken,
        castAt: vote.castAt,
        election: {
          id: vote.electionId._id,
          title: vote.electionId.title,
          status: vote.electionId.status,
          startDate: vote.electionId.startDate,
          endDate: vote.electionId.endDate
        },
        candidate: {
          id: vote.candidateId._id,
          name: vote.candidateId.userId.name,
          branch: vote.candidateId.userId.branch,
          year: vote.candidateId.userId.year,
          position: vote.candidateId.position
        },
        results: {
          winner: winner ? winner.name : null,
          winnerVotes: winner ? winner.votes : 0,
          userCandidateVotes: userCandidateResult ? userCandidateResult.votes : 0,
          userCandidateRank: userCandidateResult ? userCandidateResult.rank : null,
          totalVotes: totalVotesForPosition,
          userCandidatePercentage: userCandidateResult && totalVotesForPosition > 0 
            ? Math.round((userCandidateResult.votes / totalVotesForPosition) * 100 * 10) / 10 
            : 0,
          isWinner: winner && userCandidateResult 
            ? winner.candidateId.toString() === userCandidateResult.candidateId.toString()
            : false
        }
      };
    }));
    
    // Apply filters
    let filteredHistory = historyWithResults;
    if (filter === 'won') {
      filteredHistory = historyWithResults.filter(h => h.results.isWinner);
    } else if (filter === 'lost') {
      filteredHistory = historyWithResults.filter(h => !h.results.isWinner);
    } else if (filter === 'completed') {
      filteredHistory = historyWithResults.filter(h => h.election.status === 'completed');
    }
    
    res.json(filteredHistory);
  } catch (error) {
    console.error('Get voting history error:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// @route   GET /api/voting/statistics
// @desc    Get comprehensive voting statistics for user
// @access  Private
router.get('/statistics', auth, async (req, res) => {
  try {
    // Get all user's votes
    const userVotes = await Vote.find({ voterId: req.user.id })
      .populate('electionId', 'title status')
      .populate({
        path: 'candidateId',
        select: 'position userId',
        populate: { path: 'userId', select: 'name' }
      });
    
    // Calculate statistics
    const totalVotesCast = userVotes.length;
    const completedElections = userVotes.filter(v => v.electionId.status === 'completed');
    
    // Get winning votes
    const winningVotes = await Promise.all(completedElections.map(async (vote) => {
      const winnerResult = await Vote.aggregate([
        { $match: { 
          electionId: vote.electionId._id,
          position: vote.candidateId.position 
        }},
        { $group: { 
          _id: '$candidateId', 
          votes: { $sum: 1 } 
        }},
        { $sort: { votes: -1 } },
        { $limit: 1 }
      ]);
      
      return winnerResult.length > 0 && 
             winnerResult[0]._id.toString() === vote.candidateId._id.toString();
    }));
    
    const totalWinningVotes = winningVotes.filter(Boolean).length;
    
    // Get total eligible elections for participation rate
    const user = await User.findById(req.user.id);
    const eligibleElections = await Election.countDocuments({
      status: { $in: ['completed', 'active'] },
      allowedBranches: user.branch,
      allowedYears: user.year,
      startDate: { $lte: new Date() }
    });
    
    // Get votes by month for trending
    const votingTrend = await Vote.aggregate([
      { $match: { voterId: new mongoose.Types.ObjectId(req.user.id) } },
      { $group: {
        _id: {
          year: { $year: '$castAt' },
          month: { $month: '$castAt' }
        },
        count: { $sum: 1 }
      }},
      { $sort: { '_id.year': 1, '_id.month': 1 } }
    ]);
    
    // Get votes by position
    const votesByPosition = await Vote.aggregate([
      { $match: { voterId: new mongoose.Types.ObjectId(req.user.id) } },
      { $group: {
        _id: '$position',
        count: { $sum: 1 }
      }},
      { $sort: { count: -1 } }
    ]);
    
    const participationRate = eligibleElections > 0 
      ? Math.round((totalVotesCast / eligibleElections) * 100 * 10) / 10 
      : 0;
    
    const winRate = completedElections.length > 0 
      ? Math.round((totalWinningVotes / completedElections.length) * 100 * 10) / 10 
      : 0;
    
    res.json({
      totalVotesCast,
      completedVotes: completedElections.length,
      winningVotes: totalWinningVotes,
      participationRate,
      winRate,
      eligibleElections,
      votingTrend: votingTrend.map(t => ({
        period: `${t._id.year}-${String(t._id.month).padStart(2, '0')}`,
        votes: t.count
      })),
      votesByPosition: votesByPosition.map(v => ({
        position: v._id,
        count: v.count
      }))
    });
  } catch (error) {
    console.error('Get voting statistics error:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// @route   GET /api/voting/live-stats/:electionId
// @desc    Get real-time election statistics
// @access  Private
router.get('/live-stats/:electionId', auth, async (req, res) => {
  try {
    const election = await Election.findById(req.params.electionId);
    if (!election) {
      return res.status(404).json({ error: 'Election not found' });
    }
    
    // Get total votes for election
    const totalVotes = await Vote.countDocuments({ electionId: election._id });
    
    // Get eligible voters
    const eligibleVoters = await User.countDocuments({
      role: 'voter',
      isActive: true,
      branch: { $in: election.allowedBranches },
      year: { $in: election.allowedYears }
    });
    
    // Get votes by position
    const votesByPosition = await Vote.aggregate([
      { $match: { electionId: election._id } },
      { $group: {
        _id: '$position',
        votes: { $sum: 1 }
      }}
    ]);
    
    // Get hourly voting trend for today
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    const hourlyTrend = await Vote.aggregate([
      { $match: {
        electionId: election._id,
        castAt: { $gte: today, $lt: tomorrow }
      }},
      { $group: {
        _id: { $hour: '$castAt' },
        votes: { $sum: 1 }
      }},
      { $sort: { '_id': 1 } }
    ]);
    
    const turnoutPercentage = eligibleVoters > 0 
      ? Math.round((totalVotes / eligibleVoters) * 100 * 10) / 10 
      : 0;
    
    res.json({
      electionId: election._id,
      electionTitle: election.title,
      status: election.status,
      totalVotes,
      eligibleVoters,
      turnoutPercentage,
      votesByPosition: votesByPosition.map(v => ({
        position: v._id,
        votes: v.votes
      })),
      hourlyTrend: hourlyTrend.map(h => ({
        hour: h._id,
        votes: h.votes
      })),
      lastUpdated: new Date()
    });
  } catch (error) {
    console.error('Get live stats error:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

module.exports = router;
